
<!DOCTYPE html>
<html lang="">
<head>
    <meta charset="utf-8" />
    <title>15种算法模式 | 北尘聆音の小窝</title>
    <meta name="author" content="北尘聆音" />
    <meta name="description" content="欢迎你来看我" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>北尘聆音の小窝</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-主页 fa-fw"></i>
            <span>&ensp;主页</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-关于 fa-fw"></i>
            <span>&ensp;关于</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-归档 fa-fw"></i>
            <span>&ensp;归档</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;标签</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;北尘聆音の小窝</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-主页 fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">主页</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-关于 fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">关于</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-归档 fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">归档</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">标签</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>15种算法模式</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/1/9
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" style="color: #ffa2c4">
                    算法学习
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h2 id="1-前缀和（Prefix-Sum）"><a href="#1-前缀和（Prefix-Sum）" class="headerlink" title="1. 前缀和（Prefix Sum）"></a>1. 前缀和（Prefix Sum）</h2><p><strong>适用场景</strong>: 当你需要对子数组进行多次求和查询，或者需要计算累加和时。</p>
<p><strong>示例问题</strong>: 给定一个数组<code>nums</code>，回答关于特定区间[i, j]内元素之和的多个查询。</p>
<ul>
<li>输入：<code>nums = [1, 2, 3, 4, 5, 6]</code>，i &#x3D; 1，j &#x3D; 3</li>
<li>输出：9</li>
<li>解释：预处理数组A以创建前缀和数组：P &#x3D; [1, 3, 6, 10, 15, 21]。要找出索引i和j之间的元素和，使用公式：P[j] - P[i - 1]。</li>
</ul>
<p><strong>力扣相关题目</strong>:</p>
<span id="more"></span>

<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-immutable/">区域和检索 - 不可变</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/contiguous-array/">连续数组</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/">和为K的子数组</a></li>
</ul>
<h2 id="2-双指针（Two-Pointers）"><a href="#2-双指针（Two-Pointers）" class="headerlink" title="2. 双指针（Two Pointers）"></a>2. 双指针（Two Pointers）</h2><p><strong>适用场景</strong>: 在处理有序数组或列表，且需要查找满足特定条件的数对时。</p>
<p><strong>示例问题</strong>: 在一个有序数组中找出两个数，使其和等于目标值。</p>
<ul>
<li>输入：<code>nums = [1, 2, 3, 4, 6]</code>，target &#x3D; 6</li>
<li>输出：[1, 3]</li>
<li>解释：初始化两个指针，一个指向数组开头（左指针），一个指向数组末尾（右指针）。检查两个指针所指元素的和。如果和等于目标值，返回这两个元素的索引；如果和小于目标值，将左指针向右移动；如果和大于目标值，将右指针向左移动。</li>
</ul>
<p><strong>力扣相关题目</strong>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">两数之和 II - 输入有序数组</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">三数之和</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/">盛最多水的容器</a></li>
</ul>
<h2 id="3-滑动窗口（Sliding-Window）"><a href="#3-滑动窗口（Sliding-Window）" class="headerlink" title="3. 滑动窗口（Sliding Window）"></a>3. 滑动窗口（Sliding Window）</h2><p><strong>适用场景</strong>: 在处理涉及连续子数组或子字符串的问题时。</p>
<p><strong>示例问题</strong>: 找出大小为k的子数组的最大和。</p>
<ul>
<li>输入：<code>nums = [2, 1, 5, 1, 3, 2]</code>，k &#x3D; 3</li>
<li>输出：9</li>
<li>解释：先计算前k个元素的和。每次将窗口向右滑动一个元素，减去移出窗口的元素，再加上新进入窗口的元素。记录遇到的最大和。</li>
</ul>
<p><strong>力扣相关题目</strong>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-average-subarray-i/">最大子数组平均数 I</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a></li>
</ul>
<h2 id="4-快慢指针（Fast-Slow-Pointers）"><a href="#4-快慢指针（Fast-Slow-Pointers）" class="headerlink" title="4. 快慢指针（Fast &amp; Slow Pointers）"></a>4. 快慢指针（Fast &amp; Slow Pointers）</h2><p><strong>适用场景</strong>: 用于检测链表及其他类似结构中是否存在循环。</p>
<p><strong>示例问题</strong>: 检测一个链表是否存在循环。</p>
<ul>
<li>解释：初始化两个指针，一个每次移动一步（慢指针），另一个每次移动两步（快指针）。如果存在循环，快指针最终会与慢指针相遇；如果快指针到达链表末尾，则不存在循环。</li>
</ul>
<p><strong>力扣相关题目</strong>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">环形链表</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">快乐数</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-duplicate-number/">寻找重复数</a></li>
</ul>
<h2 id="5-链表原地反转（LinkedList-In-place-Reversal）"><a href="#5-链表原地反转（LinkedList-In-place-Reversal）" class="headerlink" title="5. 链表原地反转（LinkedList In-place Reversal）"></a>5. 链表原地反转（LinkedList In-place Reversal）</h2><p><strong>适用场景</strong>: 当你需要反转链表的某些部分时。</p>
<p><strong>示例问题</strong>: 反转链表中从位置m到n的子链表。</p>
<ul>
<li>输入：<code>head = [1, 2, 3, 4, 5]</code>，m &#x3D; 2，n &#x3D; 4</li>
<li>输出：[1, 4, 3, 2, 5]</li>
<li>解释：确定子链表的起始和结束位置。通过调整指针来原地反转节点。</li>
</ul>
<p><strong>力扣相关题目</strong>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/">反转链表 II</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">两两交换链表中的节点</a></li>
</ul>
<h2 id="6-单调栈（Monotonic-Stack）"><a href="#6-单调栈（Monotonic-Stack）" class="headerlink" title="6. 单调栈（Monotonic Stack）"></a>6. 单调栈（Monotonic Stack）</h2><p><strong>适用场景</strong>: 在需要查找下一个更大或更小元素的问题中。</p>
<p><strong>示例问题</strong>: 找出数组中每个元素的下一个更大元素。如果不存在更大元素，则输出-1。</p>
<ul>
<li>输入：<code>nums = [2, 1, 2, 4, 3]</code></li>
<li>输出：[4, 2, 4, -1, -1]</li>
<li>解释：使用栈来记录那些还未找到下一个更大元素的元素。遍历数组，对于每个元素，将栈中元素弹出，直到找到一个更大的元素。如果栈不为空，将栈顶元素对应的结果设置为当前元素。将当前元素入栈。</li>
</ul>
<p><strong>力扣相关题目</strong>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/">下一个更大元素</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">每日温度</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">柱状图中最大的矩形</a></li>
</ul>
<h2 id="7-前K大（小）元素（Top-‘K’-Elements）"><a href="#7-前K大（小）元素（Top-‘K’-Elements）" class="headerlink" title="7. 前K大（小）元素（Top ‘K’ Elements）"></a>7. 前K大（小）元素（Top ‘K’ Elements）</h2><p><strong>适用场景</strong>: 使用堆或排序的方法，从数组或数据流中找出前k个最大或最小的元素。</p>
<p><strong>示例问题</strong>: 在一个未排序的数组中找出第k个最大的元素。</p>
<ul>
<li>输入：<code>nums = [3, 2, 1, 5, 6, 4]</code>，k &#x3D; 2</li>
<li>输出：5</li>
<li>解释：使用大小为k的最小堆来跟踪k个最大元素。遍历数组，将元素加入堆中。如果堆的大小超过k，则移除堆中最小的元素。堆顶元素就是第k个最大元素。</li>
</ul>
<p><strong>力扣相关题目</strong>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">前K个高频元素</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/">最小的K对数字</a></li>
</ul>
<h2 id="8-区间重叠（Overlapping-Intervals）"><a href="#8-区间重叠（Overlapping-Intervals）" class="headerlink" title="8. 区间重叠（Overlapping Intervals）"></a>8. 区间重叠（Overlapping Intervals）</h2><p><strong>适用场景</strong>: 用于合并或处理数组中的重叠区间。</p>
<p><strong>示例问题</strong>: 给定一个区间列表，合并所有重叠的区间。</p>
<ul>
<li>输入：<code>intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]</code></li>
<li>输出：[[1, 6], [8, 10], [15, 18]]</li>
<li>解释：按区间的起始时间对区间进行排序。创建一个名为merged的空列表，用于存储合并后的区间。遍历区间，检查它是否与merged列表中的最后一个区间重叠。如果重叠，通过更新merged列表中最后一个区间的结束时间来合并区间；如果不重叠，直接将当前区间添加到merged列表中。</li>
</ul>
<p><strong>力扣相关题目</strong>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">合并区间</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-interval/">插入区间</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/">无重叠区间</a></li>
</ul>
<h2 id="9-变形二分查找（Modified-Binary-Search）"><a href="#9-变形二分查找（Modified-Binary-Search）" class="headerlink" title="9. 变形二分查找（Modified Binary Search）"></a>9. 变形二分查找（Modified Binary Search）</h2><p><strong>适用场景</strong>: 对二分查找进行改进，以解决更广泛的问题，例如在旋转排序数组中查找元素。</p>
<p><strong>示例问题</strong>: 在一个旋转排序数组中查找元素。</p>
<ul>
<li>输入：<code>nums = [4, 5, 6, 7, 0, 1, 2]</code>，target &#x3D; 0</li>
<li>输出：4</li>
<li>解释：进行二分查找时，额外增加一个判断，以确定数组的哪一半是有序的。然后检查目标元素是否在有序的那一半范围内。如果在，就在这一半中查找；否则，在另一半中查找。</li>
</ul>
<p><strong>力扣相关题目</strong>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">搜索二维矩阵 II</a></li>
</ul>
<h2 id="10-二叉树遍历（Binary-Tree-Traversal）"><a href="#10-二叉树遍历（Binary-Tree-Traversal）" class="headerlink" title="10. 二叉树遍历（Binary Tree Traversal）"></a>10. 二叉树遍历（Binary Tree Traversal）</h2><p><strong>适用场景</strong>: 按照特定顺序访问二叉树中的所有节点。</p>
<ul>
<li><strong>前序遍历</strong>：根 -&gt; 左 -&gt; 右</li>
<li><strong>中序遍历</strong>：左 -&gt; 根 -&gt; 右</li>
<li><strong>后序遍历</strong>：左 -&gt; 右 -&gt; 根</li>
</ul>
<p><strong>示例问题</strong>: 对二叉树进行中序遍历。</p>
<ul>
<li>输入：<code>root = [1, null, 2, 3]</code></li>
<li>输出：[1, 3, 2]</li>
<li>解释：中序遍历按照左、根、右的顺序访问节点。可使用递归或栈来按此顺序遍历树。</li>
</ul>
<p><strong>力扣相关题目</strong>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">二叉树的所有路径</a>（前序遍历）</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">二叉搜索树中第K小的元素</a>（中序遍历）</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">二叉树中的最大路径和</a>（后序遍历）</li>
</ul>
<h2 id="11-深度优先搜索（Depth-First-Search，DFS）"><a href="#11-深度优先搜索（Depth-First-Search，DFS）" class="headerlink" title="11. 深度优先搜索（Depth-First Search，DFS）"></a>11. 深度优先搜索（Depth-First Search，DFS）</h2><p><strong>适用场景</strong>: 遍历技术，沿着一条分支尽可能深入地探索，然后再回溯。</p>
<p><strong>示例问题</strong>: 找出二叉树中从根节点到叶节点的所有路径。</p>
<ul>
<li>输入：<code>root = [1, 2, 3, null, 5]</code></li>
<li>输出：[“1-&gt;2-&gt;5”, “1-&gt;3”]</li>
<li>解释：使用递归或栈来遍历从根节点到叶节点的每条路径。在遍历过程中记录每条路径。</li>
</ul>
<p><strong>力扣相关题目</strong>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/clone-graph/">克隆图</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">路径总和 II</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule-ii/">课程表 II</a></li>
</ul>
<h2 id="12-广度优先搜索（Breadth-First-Search，BFS）"><a href="#12-广度优先搜索（Breadth-First-Search，BFS）" class="headerlink" title="12. 广度优先搜索（Breadth-First Search，BFS）"></a>12. 广度优先搜索（Breadth-First Search，BFS）</h2><p><strong>适用场景</strong>: 按照树或图的层次依次探索节点。</p>
<p><strong>示例问题</strong>: 对二叉树进行层序遍历。</p>
<ul>
<li>输入：<code>root = [3, 9, 20, null, null, 15, 7]</code></li>
<li>输出：[[3], [9, 20], [15, 7]]</li>
<li>解释：使用队列来记录每一层的节点。遍历每一层，并将当前节点的子节点加入队列。</li>
</ul>
<p><strong>力扣相关题目</strong>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotting-oranges/">腐烂的橘子</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-ladder/">单词接龙</a></li>
</ul>
<h2 id="13-矩阵遍历（Matrix-Traversal）"><a href="#13-矩阵遍历（Matrix-Traversal）" class="headerlink" title="13. 矩阵遍历（Matrix Traversal）"></a>13. 矩阵遍历（Matrix Traversal）</h2><p><strong>适用场景</strong>: 使用不同的技术（如DFS、BFS等）遍历矩阵中的元素。</p>
<p><strong>示例问题</strong>: 对二维网格进行颜色填充。将与起始单元格相连通的所有单元格都更改为新颜色。</p>
<ul>
<li>输入：<code>image = [[1,1,1],[1,1,0],[1,0,1]]</code>，sr &#x3D; 1，sc &#x3D; 1，newColor &#x3D; 2</li>
<li>输出：[[2,2,2],[2,2,0],[2,0,1]]</li>
<li>解释：使用DFS或BFS从给定单元格开始遍历矩阵。将连通单元格的颜色更改为新颜色。</li>
</ul>
<p><strong>力扣相关题目</strong>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flood-fill/">颜色填充</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">岛屿数量</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/surrounded-regions/">被围绕的区域</a></li>
</ul>
<h2 id="14-回溯（Backtracking）"><a href="#14-回溯（Backtracking）" class="headerlink" title="14. 回溯（Backtracking）"></a>14. 回溯（Backtracking）</h2><p><strong>适用场景</strong>: 探索所有可能的解，当某条解的路径行不通时就回溯。</p>
<p><strong>示例问题</strong>: 生成给定数字列表的所有排列。</p>
<ul>
<li>输入：<code>nums = [1, 2, 3]</code></li>
<li>输出：[[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]</li>
<li>解释：使用递归来生成排列。对于每个元素，将其包含在当前排列中，并递归地生成剩余元素的排列。当某条路径下的所有排列都生成后，进行回溯。</li>
</ul>
<p><strong>力扣相关题目</strong>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">全排列</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">子集</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">N皇后问题</a></li>
</ul>
<h2 id="15-动态规划模式（Dynamic-Programming-Patterns）"><a href="#15-动态规划模式（Dynamic-Programming-Patterns）" class="headerlink" title="15. 动态规划模式（Dynamic Programming Patterns）"></a>15. 动态规划模式（Dynamic Programming Patterns）</h2><p><strong>适用场景</strong>: 将问题分解为更小的子问题，并使用自底向上或自顶向下的方法来解决它们。</p>
<p><strong>动态规划包含多个子模式</strong>:</p>
<ul>
<li>斐波那契数列</li>
<li>0&#x2F;1背包问题</li>
<li>最长公共子序列（LCS）</li>
<li>最长递增子序列（LIS）</li>
<li>子集和问题</li>
<li>矩阵链乘法</li>
</ul>
<p><strong>示例问题</strong>: 计算第n个斐波那契数。</p>
<ul>
<li>输入：n &#x3D; 5</li>
<li>输出：5（前五个斐波那契数是0，1，1，2，3，5）</li>
<li>解释：使用自底向上的方法来计算第n个斐波那契数。从最初的两个数（0和1）开始，通过迭代计算后续的数，如dp[i] &#x3D; dp[i - 1] + dp[i - 2]。</li>
</ul>
<p><strong>力扣相关题目</strong>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">零钱兑换</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">最长公共子序列</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a></li>
</ul>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2025 北尘聆音の小窝
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;北尘聆音
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
